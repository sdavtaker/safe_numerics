<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Introduction</title>
<link rel="stylesheet" href="boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="index.html" title="Safe Numerics">
<link rel="up" href="index.html" title="Safe Numerics">
<link rel="prev" href="index.html" title="Safe Numerics">
<link rel="next" href="tutorial.html" title="Tutorial and Motivating Examples">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img href="index.html" height="164px" src="pre-boost.jpg" alt="Library Documentation Index"></td>
<td><h2>Safe Numerics</h2></td>
</tr></table>
<div class="spirit-nav">
<a accesskey="p" href="index.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="tutorial.html"><img src="images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="safe_numerics.introduction"></a>Introduction</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="introduction.html#safe_numerics.introduction.problem">Problem</a></span></dt>
<dt><span class="section"><a href="introduction.html#safe_numerics.introduction.solution">Solution</a></span></dt>
<dt><span class="section"><a href="introduction.html#safe_numerics.introduction.summary">Summary</a></span></dt>
<dt><span class="section"><a href="introduction.html#safe_numerics.introduction.requirements">Requirements</a></span></dt>
<dt><span class="section"><a href="introduction.html#safe_numerics.introduction.scope">Scope</a></span></dt>
</dl></div>
<p>All data types, type requirements, function and meta function names
  are found in the namespase boost::numeric . In order to make this document
  more readable, we have omitted this namespace qualifier.</p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.introduction.problem"></a>Problem</h3></div></div></div>
<p>Arithmetic operations in C++ are NOT guaranteed to yield a correct
    mathematical result. This feature is inherited from the early days of C.
    The behavior of <code class="computeroutput">int</code>, <code class="computeroutput">unsigned int</code> and others
    were designed to map closely to the underlying hardware. Computer hardware
    implements these types as a fixed number of bits. When the result of
    arithmetic operations exceeds this number of bits, the result will not be
    arithmetically correct. The following example illustrates this
    problem.</p>
<pre class="programlisting">int f(int x, int y){
    // this returns an invalid result for some legal values of x and y !
    return x + y;
}
</pre>
<p>It is incumbent up the C/C++ programmer to guarantee that this
    behavior does not result in incorrect or unexpected operation of the
    program. There are no language facilities which do this. They have to be
    explicitly addressed in the program code. There are a number of ways to do
    this. See<a class="link" href="bibliography.html#INT32-C">[<a class="citation" href="bibliography.html#idp140530282076832"><span class="citation">INT32-C</span></a>]</a> seems
    to recommend the following approach.</p>
<pre class="programlisting">int f(int x, int y){
  if (((y &gt; 0) &amp;&amp; (x &gt; (INT_MAX - y))) 
  || ((y &lt; 0) &amp;&amp; (x &lt; (INT_MIN - x)))) {
    /* Handle error */
  }
  return x + y;
}
</pre>
<p>This will indeed trap the error. However, it would be tedious and
    laborious for a programmer to do alter his code to do. Altering code in
    this way for all arithmetic operations would likely render the code
    unreadable and add another source of potential programming errors. This
    approach is clearly not functional when the expression is even a little
    more complex as is shown in the following example.</p>
<pre class="programlisting">int f(int x, int y, int z){
    // this returns an invalid result for some legal values of x and y !
    return x + y * z;
}
</pre>
<p>Similar problems can be fount in the family of floating point data
    types. In the following example we show how adding two finite values can
    result in an infinite one.</p>
<pre class="programlisting">#include &lt;iostream&gt;
#include &lt;limits&gt;

int main(){
using namespace std;
float a = numeric_limits&lt;float&gt;::max();
float b = a + numeric_limits&lt;float&gt;::max();
cout &lt;&lt; "b is " &lt;&lt; b &lt;&lt; endl;

return 0;
}</pre>
<p>Executing this code outputs:</p>
<pre class="programlisting">b is inf</pre>
<p>This fallback to infinite for overflow is a convenient in some
    contexts, but an unexpected silent surprise in others. Overflow to
    infinite is not the only surprice silently introduced by floating point
    operations, neither the most dangerous. it is actually the one most
    programmers care to check.</p>
<p>In 1991, David Goldberg collected a list of the most common dangers
    when developing using Floating Point, which can be found on his paper:
    "What every computer scientist should know about floating-point
    arithmetic".</p>
<p>Most important dangers can be classified as follows:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p>Rounding error</p>
<p>Some operations may require rounding the result. (i.e. because
          the mantissa is not large enough to keep the result.)</p>
<p>Definition error. (i.e. 0.3 is not expressible as Floating
          Point.)</p>
<p>An interesting side-effect of rounding is that operations are
          not guaranteed to be reversible: a != a+b-b is a valid
          result.</p>
</li>
<li class="listitem">
<p>Not a Number</p>
<p>Some operations may produce Not a Number results, and they are
          not detected until used (if signalling is on).</p>
</li>
<li class="listitem">
<p>Infinity by overflow</p>
<p>Infinity arithmetic is useful mostly when infinity values are
          defined by user, and not because of an overflow.</p>
</li>
<li class="listitem">
<p>Signed zero</p>
<p>In some cases as discontinuous functions the negative zero
          have important use.</p>
</li>
<li class="listitem"><p>Underflow (considering and not considering normalised numbers
          as underflow)</p></li>
</ul></div>
<p>Another reason to be interest in these silent behavoirs are the
    security implications of ignoring them. The CERT publishes standards for
    secure coding practices, these standards raises concerns about how to
    improper use of floating point variables may introduce security holes to
    the produced software. In the following section, we show examples of how
    some of these concerns can be catched using safe_numerics for floating
    point data types.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.introduction.solution"></a>Solution</h3></div></div></div>
<p>This library implements special versions of int, unsigned, etc.
    which behave exactly like the original ones EXCEPT that the results of
    these operations are guaranteed to be either arithmetically correct or
    invoke a error. Using this library, the above would be rendered as:</p>
<pre class="programlisting">#include &lt;boost/safe_numeric/safe_integer.hpp&gt;

int f(safe&lt;int&gt; x, safe&lt;int&gt; y){
  return x + y; // throw exception if correct result cannot be returned
}
</pre>
<p>The addition expression is checked at runtime or (if possible)
    compile time to trap any possible errors resulting from incorrect
    arithmetic behavior. This will permit one to write arithmetic expressions
    that cannot produce an erroneous result. Instead, one and only one of the
    following is guaranteed to occur.</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>the expression will emit a compilation error.</p></li>
<li class="listitem"><p>the expression will invoke a runtime exception.</p></li>
<li class="listitem"><p>the expression will yield the correct mathematical
          result</p></li>
</ul></div>
<p>In addition to eliminating undefined behavior from
    primitive integer types, we define new data types
    <code class="computeroutput">safe_signed_range&lt;MIN, MAX&gt;</code> and
    <code class="computeroutput">safe_unsigned_range&lt;MIN, MAX&gt;</code> which will throw an
    exception if an attempt is made to store a result which is outside the
    closed range [MIN, MAX].</p>
<p>In the case of floating point data types, several algorithms (mostly
    comming from matrix numerical methods) account for imprecisions of the
    data types and work properly without monitoring for them, anyway
    overflows, underflows or other conditions may still be relevant. The only
    way to know what to check is thru user information of the context. </p>
<p>Catching this conditions was very difficult in the past; since C++11
    standard introduced cfenv.h it was highly facilitate to access Floating
    Point Unit flags controlling and checking information on Floating Point
    environment. </p>
<p>Anyway, developer intervention is required for checking every
    Floating Point operation was conducted as expected. Doing so, renders the
    code harder to read, maintain and it adds a new source of potential
    programming errors.</p>
<p>The goal for Floating points in SafeNumerics is the introduction of
    a drop-in replacement of native floating point data types (float, double,
    long double) introducing safety checks for arithmetic operations, and in
    the case an operation result is unreliable, reporting the user
    properly.</p>
<p>Since the reliability of the results is based on the algorithms
    used, we propose users to declare their concerns using template parameters
    as policies.</p>
<p>We show some usage examples below for illustration.</p>
<pre class="programlisting">//no underflow example

safe_numerics&lt;double, no_underflow&gt; a = 1;

safe_numerics&lt;double, no_underflow&gt; b = numeric_limits&lt;double&gt;::max();

safe_numerics&lt;double, no_underflow&gt; c =  a / b ; //throws because of underflow.

//no rounding example

safe_numerics&lt;double, no_rounding&gt; d = 0.3SNF; // compilation error, the number is not representable.

safe_numerics&lt;double, no_rounding&gt; e = 2E25SNF; 

safe_numerics&lt;double, no_rounding&gt; f = 2E100SNF;

safe_numerics&lt;double, no_rounding&gt; g = e + f ; //throws because of operation rounding.

//multiple conditions example

safe_numerics&lt;double, no_rounding | no_overflow_to_infinity &gt; h = numeric_limits&lt;double&gt;::max();

safe_numerics&lt;double, BSF_COMBINE(no_rounding,no_overflow_to_infinity)&gt; i =  numeric_limits&lt;double&gt;::max();

safe_numerics&lt;double, BSF_COMBINE(no_rounding-no_overflow_to_infinity)&gt; j = h + i; // throws because of overflow to infinity.</pre>
<p></p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.introduction.summary"></a>Summary</h3></div></div></div>
<p>Using techniques of C++ including overloading, template
    metaprogramming, and others, this library implements special versions of
    int, unsigned, etc. named <code class="computeroutput">safe&lt;int&gt;</code>,
    <code class="computeroutput">safe&lt;unsigned int&gt;, safe&lt;float&gt;,</code> etc. These
    behave exactly like the original ones EXCEPT that expressions involving
    these types are checked to guarantee any unexpected arithmetic errors are
    trapped at compile time (if possible) or at runtime. Since these types are
    meant to be "drop-in" replacements - they function in all other ways the
    same as the built-in types they are meant to replace. So things which are
    legal - such as assigning an signed to unsigned value are not trapped at
    compile time - as they are legal C/C++ code - but rather checked at
    runtime to trap the case where this (legal) operation would lead to an
    arithmetically incorrect result.</p>
<p>Note that the library addresses arithmetical errors generated by
    straightforward C/C++ expressions. Some of these arithmetic errors are
    defined as conforming to C/C++ standard while others are not. So it's
    misleading to characterize this library as addressing undefined behavior
    of C/C++ numeric expressions.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.introduction.requirements"></a>Requirements</h3></div></div></div>
<p>This library is composed entirely of C++ Headers. It requires a
    compiler compatible with the C++14 standard.</p>
<p>The following Boost Libraries 1.57+ must be installed in order to
    use this library</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>mpl</p></li>
<li class="listitem"><p>integer</p></li>
<li class="listitem"><p>limits</p></li>
<li class="listitem"><p>config</p></li>
<li class="listitem"><p>concept checking</p></li>
<li class="listitem"><p>type traits</p></li>
<li class="listitem"><p>integer traits</p></li>
</ul></div>
<p>The following are requirements for testing and running
    examples only</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Boost.preprocessor</p></li>
<li class="listitem"><p>Boost.test</p></li>
</ul></div>
<p>Building scripts in cmake are provided for testing and
    examples.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.introduction.scope"></a>Scope</h3></div></div></div>
<p>This library currently applies only to built-in integer and floating
    point types. User or Library defined types such as arbitrary precision
    integers can also have this problem. Extension of this library to other
    types is not currently under development but may be addressed in the
    future. Some compilers does not implement #pragma FENV_ACCESS as defined
    in the C++11/C++14 standards, in those compilers avoiding racing
    conditions cannot be guaranteed.</p>
<p></p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2012 Robert Ramey<p><a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">Subject to Boost
      Software License</a></p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="index.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="tutorial.html"><img src="images/next.png" alt="Next"></a>
</div>
</body>
</html>
